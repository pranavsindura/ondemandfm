0)Install redux

redux,

1)Store

createStore, create a store, pass reducer
subscribe to store. store.subscribe(()=>{})
performs function everytime state changes

2)Reducer
create Reducer, takes state and action
make initial state
finish up reducer, make a copy of the state
check action
perform action
return state

3)Action
make action. store.dispatch
action has type and payload

4)Integrate w/ React

First make a state dependant app

redux, react-redux

make store/reducers.js
finish up reducer and export from above steps

store must be created at highest level.
in this case index.js
Wrapper for Store is Provider
whatever we pass to it is available gloablly

Make store, pass reducer(import first)
<Provider store={store}><App /></Provider>

Yay! no longer need states

5)Remove states

remove state dependancy from App
see in comments

now we need to map the state to our props
to access the store we need to do this to every page.
also need to be able to perform actions from every page.

mapDispatchToProps, mapStateToProps
connect these to our store

const mapStateToProps = (state)=>{
  return {
    age:state.age,
  };
}

const mapDispatchToProps= (dispatch)=>{
  return {
    onAgeUp: ()=> dispatch({type:'AGE_UP'}),
    onAgeDown: ()=> dispatch({type:'AGE_DOWN'})
  };
};

Before-> export default App;
After-> export default connect(mapStateToProps,mapDispatchToProps)(App);

Before-> this.onAgeUp
After-> this.props.onAgeUp

Before-> this.state.age
After-> this.props.age

6)Update State immutable way

instead of making copies, return {...state, <action performed in other vars>}
added action.<payload> support

If you add a new key to your state, and if you're using it in you code,
you need to put it on mapStateToProps

7) Multiple reducers

i Have saved above related codes under _prev of App.js, index.js and reducer.js
and made new ones to understand multiples reducers


first made app w/ common reducer

now separating reducers
import both in index.js

now for combining, combineReducers (redux)

const rootReducer = combineReducers({
    rA: reducerA,
    rB: reducerB
});

let store = createStore(rootReducer);

sorta like namespace
now for when we mapStateToProps
we need to include those namespace things

Before->
a: state.a,
b: state.b

After->
a: state.rA.a,
b:state.rB.b

Now, in the reducer we Have
b: state.a + state.b
but state.a no longer exists
the only place the whole state exists is in App.js
we need to pass it as a payload to our dispatch

7)Middleware

For async functions we add middleware to catch the function in the middle
like for DB/Backend requests, complete action if success else mapStateToProps
Promises and stuff

import applyMiddleware from redux

const logAction = (store)=>{
    return (next) => {
        return (action)=> {
            console.log('Caught in the middle: '+JSON.stringify(result));
            const result = next(action);
            console.log('New State: ' + JSON.stringify(store.getState()))
            return result;
        }
    }
}
const store = createStore(reducer, applyMiddleware(logAction))

read DOCS
next is basically store.dispatch()

useful middleware is redux-thunk

const crashReporter = store => next => action => {
  try {
    return next(action);
  }catch(e){
    console.log(e);
  }
}

8) redux-thunk

middleware for redux, helps in performing async calls
basically create a separate function for creating an action
then call it in another function which performs other async function

onAgeUp: () => dispatch({ type: 'AGE_UP', value: 1 })
changed to->
onAgeUp: () => dispatch(ageUp(1))
ageUp() will be imported

ageUpAsync(val){
  return {type: 'AGE_UP', value: val};
}

ageUp(val){
  //perform some action async lets say timeout
  setTimeout(()=>{
    ageUpAsync(val);
  },5000);
}
